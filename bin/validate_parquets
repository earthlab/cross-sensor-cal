#!/usr/bin/env python
from __future__ import annotations

import argparse
from pathlib import Path
import re
import sys

import pyarrow.parquet as pq


def is_ok_columns(cols):
    # non-spectral can be anything; spectral must match <stage>_b###_wl####nm
    # and be ordered by wavelength within each stage key (stage ordering may
    # interleave across the schema, especially for merged tables).
    spec = [c for c in cols if "_wl" in c]
    last_seen: dict[str, int] = {}
    for c in spec:
        m = re.search(r"(.+)_b\d+_wl(\d+)nm$", c)
        if not m:
            return False
        stage, wl_str = m.group(1), m.group(2)
        wl = int(wl_str)
        last = last_seen.get(stage, -1)
        if wl < last:
            return False
        last_seen[stage] = wl
    return True


def parse_args(argv: list[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Validate parquet sidecars produced by the pipeline.")
    parser.add_argument("path", nargs="?", default=".", help="Directory containing parquet files to validate.")
    parser.add_argument(
        "--soft",
        action="store_true",
        help="Report invalid parquet files but exit with code 0 instead of 1.",
    )
    return parser.parse_args(argv)


def collect_issues(root: Path) -> list[tuple[str, str]]:
    bad: list[tuple[str, str]] = []
    for q in sorted(root.glob("*.parquet")):
        try:
            schema = pq.read_schema(q)
        except Exception as exc:  # pragma: no cover - defensive, should rarely happen
            bad.append((q.name, f"unable to read schema ({exc}). Delete or regenerate this file."))
            continue
        cols = list(schema.names)
        if "lon" not in cols or "lat" not in cols:
            bad.append(
                (
                    q.name,
                    f"missing lat/lon (try: bin/repair_lonlat_in_place {q.parent})",
                )
            )
            continue
        if not is_ok_columns(cols):
            bad.append((q.name, "spectral columns unsorted or misnamed"))
    return bad


def main(argv: list[str] | None = None) -> int:
    args = parse_args(argv)
    root = Path(args.path)
    bad = collect_issues(root)
    if bad:
        print("❌ Issues found:")
        for name, msg in bad:
            print(" -", name, "→", msg)
        return 0 if args.soft else 1

    print("✅ All parquet files look consistent.")
    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
